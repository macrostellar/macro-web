{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/plus.js","sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/lucide-react/src/icons/plus.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M5 12h14', key: '1ays0h' }],\n  ['path', { d: 'M12 5v14', key: 's699le' }],\n];\n\n/**\n * @component @name Plus\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNNSAxMmgxNCIgLz4KICA8cGF0aCBkPSJNMTIgNXYxNCIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/plus\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Plus = createLucideIcon('plus', __iconNode);\n\nexport default Plus;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACzC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;CAC3C;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,IAAA,CAAA,CAAA,KAAO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,8JAAA,EAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAQ,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/trash-2.js","sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/lucide-react/src/icons/trash-2.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M10 11v6', key: 'nco0om' }],\n  ['path', { d: 'M14 11v6', key: 'outv1u' }],\n  ['path', { d: 'M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6', key: 'miytrc' }],\n  ['path', { d: 'M3 6h18', key: 'd0wm0j' }],\n  ['path', { d: 'M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2', key: 'e791ji' }],\n];\n\n/**\n * @component @name Trash2\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTAgMTF2NiIgLz4KICA8cGF0aCBkPSJNMTQgMTF2NiIgLz4KICA8cGF0aCBkPSJNMTkgNnYxNGEyIDIgMCAwIDEtMiAySDdhMiAyIDAgMCAxLTItMlY2IiAvPgogIDxwYXRoIGQ9Ik0zIDZoMTgiIC8+CiAgPHBhdGggZD0iTTggNlY0YTIgMiAwIDAgMSAyLTJoNGEyIDIgMCAwIDEgMiAydjIiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/trash-2\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Trash2 = createLucideIcon('trash-2', __iconNode);\n\nexport default Trash2;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACzC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAY,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACzC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAA4C,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACzE;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAW,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACxC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,GAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAA0C,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;CACzE;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,MAAA,CAAA,CAAA,KAAS,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,8JAAA,EAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAW,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/pen.js","sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/lucide-react/src/icons/pen.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  [\n    'path',\n    {\n      d: 'M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z',\n      key: '1a8usu',\n    },\n  ],\n];\n\n/**\n * @component @name Pen\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjEuMTc0IDYuODEyYTEgMSAwIDAgMC0zLjk4Ni0zLjk4N0wzLjg0MiAxNi4xNzRhMiAyIDAgMCAwLS41LjgzbC0xLjMyMSA0LjM1MmEuNS41IDAgMCAwIC42MjMuNjIybDQuMzUzLTEuMzJhMiAyIDAgMCAwIC44My0uNDk3eiIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/pen\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Pen = createLucideIcon('pen', __iconNode);\n\nexport default Pen;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QACE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QACA;YACE,CAAA,EAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YACH,GAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA;KACP;CAEJ;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,GAAA,CAAA,CAAA,KAAM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,8JAAA,EAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,EAAO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}},
    {"offset": {"line": 153, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/map-pin.js","sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/lucide-react/src/icons/map-pin.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  [\n    'path',\n    {\n      d: 'M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0',\n      key: '1r0f0z',\n    },\n  ],\n  ['circle', { cx: '12', cy: '10', r: '3', key: 'ilqhr7' }],\n];\n\n/**\n * @component @name MapPin\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjAgMTBjMCA0Ljk5My01LjUzOSAxMC4xOTMtNy4zOTkgMTEuNzk5YTEgMSAwIDAgMS0xLjIwMiAwQzkuNTM5IDIwLjE5MyA0IDE0Ljk5MyA0IDEwYTggOCAwIDAgMSAxNiAwIiAvPgogIDxjaXJjbGUgY3g9IjEyIiBjeT0iMTAiIHI9IjMiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/map-pin\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst MapPin = createLucideIcon('map-pin', __iconNode);\n\nexport default MapPin;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QACE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QACA;YACE,CAAA,EAAG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YACH,GAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA;KAET;IACA;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAU;YAAE,CAAA,CAAA,CAAA,CAAI,IAAA,CAAA;YAAM,CAAA,CAAA,EAAI,CAAA,CAAA,CAAA,CAAA,CAAA;YAAM,CAAA,CAAA,CAAG,CAAA,CAAA,CAAA;YAAK,CAAA,CAAA,CAAA,CAAA,CAAK,QAAA;QAAA,CAAU;KAAA;CAC1D;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,MAAA,CAAA,CAAA,KAAS,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,8JAAA,EAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAW,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}},
    {"offset": {"line": 200, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/toggle-left.js","sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/lucide-react/src/icons/toggle-left.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['circle', { cx: '9', cy: '12', r: '3', key: 'u3jwor' }],\n  ['rect', { width: '20', height: '14', x: '2', y: '5', rx: '7', key: 'g7kal2' }],\n];\n\n/**\n * @component @name ToggleLeft\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8Y2lyY2xlIGN4PSI5IiBjeT0iMTIiIHI9IjMiIC8+CiAgPHJlY3Qgd2lkdGg9IjIwIiBoZWlnaHQ9IjE0IiB4PSIyIiB5PSI1IiByeD0iNyIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/toggle-left\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ToggleLeft = createLucideIcon('toggle-left', __iconNode);\n\nexport default ToggleLeft;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QAAC,QAAA,CAAA;QAAU,CAAA;YAAE,EAAA,CAAA,CAAI,CAAA,CAAA,CAAA;YAAK,CAAA,CAAA,CAAA,CAAI,IAAA,CAAA;YAAM,CAAA,EAAG,CAAA,CAAA,CAAA,CAAA;YAAK,GAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACvD;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAO,CAAA,CAAA,CAAA;YAAM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA,CAAA,CAAA,CAAA,CAAA;YAAM,CAAA,CAAA,CAAG,CAAA,CAAA,CAAA,CAAA;YAAK,GAAG,CAAA,CAAA,CAAA,CAAA;YAAK,CAAA,CAAA,CAAA,CAAI,CAAA,CAAA,CAAA,CAAA;YAAK,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;CAChF;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,KAAa,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,8JAAA,EAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAe,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}},
    {"offset": {"line": 251, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/lucide-react/dist/esm/icons/toggle-right.js","sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/lucide-react/src/icons/toggle-right.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['circle', { cx: '15', cy: '12', r: '3', key: '1afu0r' }],\n  ['rect', { width: '20', height: '14', x: '2', y: '5', rx: '7', key: 'g7kal2' }],\n];\n\n/**\n * @component @name ToggleRight\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8Y2lyY2xlIGN4PSIxNSIgY3k9IjEyIiByPSIzIiAvPgogIDxyZWN0IHdpZHRoPSIyMCIgaGVpZ2h0PSIxNCIgeD0iMiIgeT0iNSIgcng9IjciIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/toggle-right\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ToggleRight = createLucideIcon('toggle-right', __iconNode);\n\nexport default ToggleRight;\n"],"names":[],"mappings":";;;;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAA,CAAA,CAAA,CAAuB;IAClC;QAAC,QAAA,CAAA;QAAU,CAAA;YAAE,EAAA,CAAA,CAAI,CAAA,CAAA,CAAA,CAAA;YAAM,CAAA,CAAA,CAAA,CAAI,IAAA,CAAA;YAAM,CAAA,EAAG,CAAA,CAAA,CAAA,CAAA;YAAK,GAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;IACxD;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAQ,CAAA;YAAE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAO,CAAA,CAAA,CAAA;YAAM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA,CAAA,CAAA,CAAA,CAAA;YAAM,CAAA,CAAA,CAAG,CAAA,CAAA,CAAA,CAAA;YAAK,GAAG,CAAA,CAAA,CAAA,CAAA;YAAK,CAAA,CAAA,CAAA,CAAI,CAAA,CAAA,CAAA,CAAA;YAAK,CAAA,CAAA,CAAA,CAAA,CAAK,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QAAA,CAAU;KAAA;CAChF;AAaA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,WAAA,CAAA,CAAA,KAAc,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,8JAAA,EAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAgB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAU,CAAA"}},
    {"offset": {"line": 301, "column": 0}, "map": {"version":3,"sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/wgs84/index.js"],"sourcesContent":["module.exports.RADIUS = 6378137;\nmodule.exports.FLATTENING = 1/298.257223563;\nmodule.exports.POLAR_RADIUS = 6356752.3142;\n"],"names":[],"mappings":"AAAA,OAAO,OAAO,CAAC,MAAM,GAAG;AACxB,OAAO,OAAO,CAAC,UAAU,GAAG,IAAE;AAC9B,OAAO,OAAO,CAAC,YAAY,GAAG","ignoreList":[0]}},
    {"offset": {"line": 307, "column": 0}, "map": {"version":3,"sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/%40mapbox/geojson-area/index.js"],"sourcesContent":["var wgs84 = require('wgs84');\n\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\n\nfunction geometry(_) {\n    var area = 0, i;\n    switch (_.type) {\n        case 'Polygon':\n            return polygonArea(_.coordinates);\n        case 'MultiPolygon':\n            for (i = 0; i < _.coordinates.length; i++) {\n                area += polygonArea(_.coordinates[i]);\n            }\n            return area;\n        case 'Point':\n        case 'MultiPoint':\n        case 'LineString':\n        case 'MultiLineString':\n            return 0;\n        case 'GeometryCollection':\n            for (i = 0; i < _.geometries.length; i++) {\n                area += geometry(_.geometries[i]);\n            }\n            return area;\n    }\n}\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\nfunction ringArea(coords) {\n    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,\n    area = 0,\n    coordsLength = coords.length;\n\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {// i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength -1;\n                upperIndex = 0;\n            } else if (i === coordsLength - 1) {// i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            } else { // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i+1;\n                upperIndex = i+2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));\n        }\n\n        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}"],"names":[],"mappings":"AAAA,IAAI;AAEJ,OAAO,OAAO,CAAC,QAAQ,GAAG;AAC1B,OAAO,OAAO,CAAC,IAAI,GAAG;AAEtB,SAAS,SAAS,CAAC;IACf,IAAI,OAAO,GAAG;IACd,OAAQ,EAAE,IAAI;QACV,KAAK;YACD,OAAO,YAAY,EAAE,WAAW;QACpC,KAAK;YACD,IAAK,IAAI,GAAG,IAAI,EAAE,WAAW,CAAC,MAAM,EAAE,IAAK;gBACvC,QAAQ,YAAY,EAAE,WAAW,CAAC,EAAE;YACxC;YACA,OAAO;QACX,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACD,OAAO;QACX,KAAK;YACD,IAAK,IAAI,GAAG,IAAI,EAAE,UAAU,CAAC,MAAM,EAAE,IAAK;gBACtC,QAAQ,SAAS,EAAE,UAAU,CAAC,EAAE;YACpC;YACA,OAAO;IACf;AACJ;AAEA,SAAS,YAAY,MAAM;IACvB,IAAI,OAAO;IACX,IAAI,UAAU,OAAO,MAAM,GAAG,GAAG;QAC7B,QAAQ,KAAK,GAAG,CAAC,SAAS,MAAM,CAAC,EAAE;QACnC,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,IAAK;YACpC,QAAQ,KAAK,GAAG,CAAC,SAAS,MAAM,CAAC,EAAE;QACvC;IACJ;IACA,OAAO;AACX;AAEA;;;;;;;;;;;;;CAaC,GAED,SAAS,SAAS,MAAM;IACpB,IAAI,IAAI,IAAI,IAAI,YAAY,aAAa,YAAY,GACrD,OAAO,GACP,eAAe,OAAO,MAAM;IAE5B,IAAI,eAAe,GAAG;QAClB,IAAK,IAAI,GAAG,IAAI,cAAc,IAAK;YAC/B,IAAI,MAAM,eAAe,GAAG;gBACxB,aAAa,eAAe;gBAC5B,cAAc,eAAc;gBAC5B,aAAa;YACjB,OAAO,IAAI,MAAM,eAAe,GAAG;gBAC/B,aAAa,eAAe;gBAC5B,cAAc;gBACd,aAAa;YACjB,OAAO;gBACH,aAAa;gBACb,cAAc,IAAE;gBAChB,aAAa,IAAE;YACnB;YACA,KAAK,MAAM,CAAC,WAAW;YACvB,KAAK,MAAM,CAAC,YAAY;YACxB,KAAK,MAAM,CAAC,WAAW;YACvB,QAAQ,CAAE,IAAI,EAAE,CAAC,EAAE,IAAI,IAAI,EAAE,CAAC,EAAE,CAAE,IAAI,KAAK,GAAG,CAAE,IAAI,EAAE,CAAC,EAAE;QAC7D;QAEA,OAAO,OAAO,MAAM,MAAM,GAAG,MAAM,MAAM,GAAG;IAChD;IAEA,OAAO;AACX;AAEA,SAAS,IAAI,CAAC;IACV,OAAO,IAAI,KAAK,EAAE,GAAG;AACzB","ignoreList":[0]}},
    {"offset": {"line": 388, "column": 0}, "map": {"version":3,"sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/%40mapbox/mapbox-gl-draw/node_modules/nanoid/non-secure/index.js"],"sourcesContent":["/* @ts-self-types=\"./index.d.ts\" */\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nexport let customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size | 0\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let i = size | 0\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n"],"names":[],"mappings":"AAAA,iCAAiC;;;;;;AACjC,IAAI,cACF;AACK,IAAI,iBAAiB,CAAC,UAAU,cAAc,EAAE;IACrD,OAAO,CAAC,OAAO,WAAW;QACxB,IAAI,KAAK;QACT,IAAI,IAAI,OAAO;QACf,MAAO,IAAK;YACV,MAAM,QAAQ,CAAC,AAAC,KAAK,MAAM,KAAK,SAAS,MAAM,GAAI,EAAE;QACvD;QACA,OAAO;IACT;AACF;AACO,IAAI,SAAS,CAAC,OAAO,EAAE;IAC5B,IAAI,KAAK;IACT,IAAI,IAAI,OAAO;IACf,MAAO,IAAK;QACV,MAAM,WAAW,CAAC,AAAC,KAAK,MAAM,KAAK,KAAM,EAAE;IAC7C;IACA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 417, "column": 0}, "map": {"version":3,"sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/%40mapbox/point-geometry/index.js"],"sourcesContent":["/**\n * A standalone point geometry with useful accessor, comparison, and\n * modification methods.\n *\n * @class\n * @param {number} x the x-coordinate. This could be longitude or screen pixels, or any other sort of unit.\n * @param {number} y the y-coordinate. This could be latitude or screen pixels, or any other sort of unit.\n *\n * @example\n * const point = new Point(-77, 38);\n */\nexport default function Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype = {\n    /**\n     * Clone this point, returning a new point that can be modified\n     * without affecting the old one.\n     * @return {Point} the clone\n     */\n    clone() { return new Point(this.x, this.y); },\n\n    /**\n     * Add this point's x & y coordinates to another point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    add(p) { return this.clone()._add(p); },\n\n    /**\n     * Subtract this point's x & y coordinates to from point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    sub(p) { return this.clone()._sub(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    multByPoint(p) { return this.clone()._multByPoint(p); },\n\n    /**\n     * Divide this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    divByPoint(p) { return this.clone()._divByPoint(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {number} k factor\n     * @return {Point} output point\n     */\n    mult(k) { return this.clone()._mult(k); },\n\n    /**\n     * Divide this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {number} k factor\n     * @return {Point} output point\n     */\n    div(k) { return this.clone()._div(k); },\n\n    /**\n     * Rotate this point around the 0, 0 origin by an angle a,\n     * given in radians\n     * @param {number} a angle to rotate around, in radians\n     * @return {Point} output point\n     */\n    rotate(a) { return this.clone()._rotate(a); },\n\n    /**\n     * Rotate this point around p point by an angle a,\n     * given in radians\n     * @param {number} a angle to rotate around, in radians\n     * @param {Point} p Point to rotate around\n     * @return {Point} output point\n     */\n    rotateAround(a, p) { return this.clone()._rotateAround(a, p); },\n\n    /**\n     * Multiply this point by a 4x1 transformation matrix\n     * @param {[number, number, number, number]} m transformation matrix\n     * @return {Point} output point\n     */\n    matMult(m) { return this.clone()._matMult(m); },\n\n    /**\n     * Calculate this point but as a unit vector from 0, 0, meaning\n     * that the distance from the resulting point to the 0, 0\n     * coordinate will be equal to 1 and the angle from the resulting\n     * point to the 0, 0 coordinate will be the same as before.\n     * @return {Point} unit vector point\n     */\n    unit() { return this.clone()._unit(); },\n\n    /**\n     * Compute a perpendicular point, where the new y coordinate\n     * is the old x coordinate and the new x coordinate is the old y\n     * coordinate multiplied by -1\n     * @return {Point} perpendicular point\n     */\n    perp() { return this.clone()._perp(); },\n\n    /**\n     * Return a version of this point with the x & y coordinates\n     * rounded to integers.\n     * @return {Point} rounded point\n     */\n    round() { return this.clone()._round(); },\n\n    /**\n     * Return the magnitude of this point: this is the Euclidean\n     * distance from the 0, 0 coordinate to this point's x and y\n     * coordinates.\n     * @return {number} magnitude\n     */\n    mag() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n\n    /**\n     * Judge whether this point is equal to another point, returning\n     * true or false.\n     * @param {Point} other the other point\n     * @return {boolean} whether the points are equal\n     */\n    equals(other) {\n        return this.x === other.x &&\n               this.y === other.y;\n    },\n\n    /**\n     * Calculate the distance from this point to another point\n     * @param {Point} p the other point\n     * @return {number} distance\n     */\n    dist(p) {\n        return Math.sqrt(this.distSqr(p));\n    },\n\n    /**\n     * Calculate the distance from this point to another point,\n     * without the square root step. Useful if you're comparing\n     * relative distances.\n     * @param {Point} p the other point\n     * @return {number} distance\n     */\n    distSqr(p) {\n        const dx = p.x - this.x,\n            dy = p.y - this.y;\n        return dx * dx + dy * dy;\n    },\n\n    /**\n     * Get the angle from the 0, 0 coordinate to this point, in radians\n     * coordinates.\n     * @return {number} angle\n     */\n    angle() {\n        return Math.atan2(this.y, this.x);\n    },\n\n    /**\n     * Get the angle from this point to another point, in radians\n     * @param {Point} b the other point\n     * @return {number} angle\n     */\n    angleTo(b) {\n        return Math.atan2(this.y - b.y, this.x - b.x);\n    },\n\n    /**\n     * Get the angle between this point and another point, in radians\n     * @param {Point} b the other point\n     * @return {number} angle\n     */\n    angleWith(b) {\n        return this.angleWithSep(b.x, b.y);\n    },\n\n    /**\n     * Find the angle of the two vectors, solving the formula for\n     * the cross product a x b = |a||b|sin(θ) for θ.\n     * @param {number} x the x-coordinate\n     * @param {number} y the y-coordinate\n     * @return {number} the angle in radians\n     */\n    angleWithSep(x, y) {\n        return Math.atan2(\n            this.x * y - this.y * x,\n            this.x * x + this.y * y);\n    },\n\n    /** @param {[number, number, number, number]} m */\n    _matMult(m) {\n        const x = m[0] * this.x + m[1] * this.y,\n            y = m[2] * this.x + m[3] * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _add(p) {\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _sub(p) {\n        this.x -= p.x;\n        this.y -= p.y;\n        return this;\n    },\n\n    /** @param {number} k */\n    _mult(k) {\n        this.x *= k;\n        this.y *= k;\n        return this;\n    },\n\n    /** @param {number} k */\n    _div(k) {\n        this.x /= k;\n        this.y /= k;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _multByPoint(p) {\n        this.x *= p.x;\n        this.y *= p.y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _divByPoint(p) {\n        this.x /= p.x;\n        this.y /= p.y;\n        return this;\n    },\n\n    _unit() {\n        this._div(this.mag());\n        return this;\n    },\n\n    _perp() {\n        const y = this.y;\n        this.y = this.x;\n        this.x = -y;\n        return this;\n    },\n\n    /** @param {number} angle */\n    _rotate(angle) {\n        const cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = cos * this.x - sin * this.y,\n            y = sin * this.x + cos * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    /**\n     * @param {number} angle\n     * @param {Point} p\n     */\n    _rotateAround(angle, p) {\n        const cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _round() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        return this;\n    },\n\n    constructor: Point\n};\n\n/**\n * Construct a point from an array if necessary, otherwise if the input\n * is already a Point, return it unchanged.\n * @param {Point | [number, number] | {x: number, y: number}} p input value\n * @return {Point} constructed point.\n * @example\n * // this\n * var point = Point.convert([0, 1]);\n * // is equivalent to\n * var point = new Point(0, 1);\n */\nPoint.convert = function (p) {\n    if (p instanceof Point) {\n        return /** @type {Point} */ (p);\n    }\n    if (Array.isArray(p)) {\n        return new Point(+p[0], +p[1]);\n    }\n    if (p.x !== undefined && p.y !== undefined) {\n        return new Point(+p.x, +p.y);\n    }\n    throw new Error('Expected [x, y] or {x, y} point format');\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 696, "column": 0}, "map": {"version":3,"sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/%40turf/helpers/index.ts"],"sourcesContent":["import {\n  BBox,\n  Feature,\n  FeatureCollection,\n  Geometry,\n  GeometryCollection,\n  GeometryObject,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n  Position,\n  GeoJsonProperties,\n} from \"geojson\";\n\nimport { Id } from \"./lib/geojson.js\";\nexport * from \"./lib/geojson.js\";\n\n/**\n * @module helpers\n */\n\n// TurfJS Combined Types\nexport type Coord = Feature<Point> | Point | Position;\n\n/**\n * Linear measurement units.\n *\n * ⚠️ Warning. Be aware of the implications of using radian or degree units to\n * measure distance. The distance represented by a degree of longitude *varies*\n * depending on latitude.\n *\n * See https://www.thoughtco.com/degree-of-latitude-and-longitude-distance-4070616\n * for an illustration of this behaviour.\n *\n * @typedef\n */\nexport type Units =\n  | \"meters\"\n  | \"metres\"\n  | \"millimeters\"\n  | \"millimetres\"\n  | \"centimeters\"\n  | \"centimetres\"\n  | \"kilometers\"\n  | \"kilometres\"\n  | \"miles\"\n  | \"nauticalmiles\"\n  | \"inches\"\n  | \"yards\"\n  | \"feet\"\n  | \"radians\"\n  | \"degrees\";\n\n/**\n * Area measurement units.\n *\n * @typedef\n */\nexport type AreaUnits =\n  | Exclude<Units, \"radians\" | \"degrees\">\n  | \"acres\"\n  | \"hectares\";\n\n/**\n * Grid types.\n *\n * @typedef\n */\nexport type Grid = \"point\" | \"square\" | \"hex\" | \"triangle\";\n\n/**\n * Shorthand corner identifiers.\n *\n * @typedef\n */\nexport type Corners = \"sw\" | \"se\" | \"nw\" | \"ne\" | \"center\" | \"centroid\";\n\n/**\n * Geometries made up of lines i.e. lines and polygons.\n *\n * @typedef\n */\nexport type Lines = LineString | MultiLineString | Polygon | MultiPolygon;\n\n/**\n * Convenience type for all possible GeoJSON.\n *\n * @typedef\n */\nexport type AllGeoJSON =\n  | Feature\n  | FeatureCollection\n  | Geometry\n  | GeometryCollection;\n\n/**\n * The Earth radius in meters. Used by Turf modules that model the Earth as a sphere. The {@link https://en.wikipedia.org/wiki/Earth_radius#Arithmetic_mean_radius mean radius} was selected because it is {@link https://rosettacode.org/wiki/Haversine_formula#:~:text=This%20value%20is%20recommended recommended } by the Haversine formula (used by turf/distance) to reduce error.\n *\n * @constant\n */\nexport const earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors based on earthRadius.\n *\n * Keys are the name of the unit, values are the number of that unit in a single radian\n *\n * @constant\n */\nexport const factors: Record<Units, number> = {\n  centimeters: earthRadius * 100,\n  centimetres: earthRadius * 100,\n  degrees: 360 / (2 * Math.PI),\n  feet: earthRadius * 3.28084,\n  inches: earthRadius * 39.37,\n  kilometers: earthRadius / 1000,\n  kilometres: earthRadius / 1000,\n  meters: earthRadius,\n  metres: earthRadius,\n  miles: earthRadius / 1609.344,\n  millimeters: earthRadius * 1000,\n  millimetres: earthRadius * 1000,\n  nauticalmiles: earthRadius / 1852,\n  radians: 1,\n  yards: earthRadius * 1.0936,\n};\n\n/**\n\n * Area of measurement factors based on 1 square meter.\n *\n * @constant\n */\nexport const areaFactors: Record<AreaUnits, number> = {\n  acres: 0.000247105,\n  centimeters: 10000,\n  centimetres: 10000,\n  feet: 10.763910417,\n  hectares: 0.0001,\n  inches: 1550.003100006,\n  kilometers: 0.000001,\n  kilometres: 0.000001,\n  meters: 1,\n  metres: 1,\n  miles: 3.86e-7,\n  nauticalmiles: 2.9155334959812285e-7,\n  millimeters: 1000000,\n  millimetres: 1000000,\n  yards: 1.195990046,\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @function\n * @param {GeometryObject} geometry input geometry\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryObject, GeoJsonProperties>} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature<\n  G extends GeometryObject = Geometry,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  geom: G | null,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<G, P> {\n  const feat: any = { type: \"Feature\" };\n  if (options.id === 0 || options.id) {\n    feat.id = options.id;\n  }\n  if (options.bbox) {\n    feat.bbox = options.bbox;\n  }\n  feat.properties = properties || {};\n  feat.geometry = geom;\n  return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @function\n * @param {(\"Point\" | \"LineString\" | \"Polygon\" | \"MultiPoint\" | \"MultiLineString\" | \"MultiPolygon\")} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(\n  type:\n    | \"Point\"\n    | \"LineString\"\n    | \"Polygon\"\n    | \"MultiPoint\"\n    | \"MultiLineString\"\n    | \"MultiPolygon\",\n  coordinates: any[],\n  _options: Record<string, never> = {}\n) {\n  switch (type) {\n    case \"Point\":\n      return point(coordinates).geometry;\n    case \"LineString\":\n      return lineString(coordinates).geometry;\n    case \"Polygon\":\n      return polygon(coordinates).geometry;\n    case \"MultiPoint\":\n      return multiPoint(coordinates).geometry;\n    case \"MultiLineString\":\n      return multiLineString(coordinates).geometry;\n    case \"MultiPolygon\":\n      return multiPolygon(coordinates).geometry;\n    default:\n      throw new Error(type + \" is invalid\");\n  }\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @function\n * @param {Position} coordinates longitude, latitude position (each in decimal degrees)\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point, GeoJsonProperties>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<Point, P> {\n  if (!coordinates) {\n    throw new Error(\"coordinates is required\");\n  }\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"coordinates must be an Array\");\n  }\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be at least 2 numbers long\");\n  }\n  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n    throw new Error(\"coordinates must contain numbers\");\n  }\n\n  const geom: Point = {\n    type: \"Point\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @function\n * @param {Position[]} coordinates an array of Points\n * @param {GeoJsonProperties} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {Id} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<Point, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return point(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @function\n * @param {Position[][]} coordinates an array of LinearRings\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon, GeoJsonProperties>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<Polygon, P> {\n  for (const ring of coordinates) {\n    if (ring.length < 4) {\n      throw new Error(\n        \"Each LinearRing of a Polygon must have 4 or more Positions.\"\n      );\n    }\n\n    if (ring[ring.length - 1].length !== ring[0].length) {\n      throw new Error(\"First and last Position are not equivalent.\");\n    }\n\n    for (let j = 0; j < ring[ring.length - 1].length; j++) {\n      // Check if first point of Polygon contains two numbers\n      if (ring[ring.length - 1][j] !== ring[0][j]) {\n        throw new Error(\"First and last Position are not equivalent.\");\n      }\n    }\n  }\n  const geom: Polygon = {\n    type: \"Polygon\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @function\n * @param {Position[][][]} coordinates an array of Polygon coordinates\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon, GeoJsonProperties>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<Polygon, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return polygon(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @function\n * @param {Position[]} coordinates an array of Positions\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString, GeoJsonProperties>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<LineString, P> {\n  if (coordinates.length < 2) {\n    throw new Error(\"coordinates must be an array of two or more positions\");\n  }\n  const geom: LineString = {\n    type: \"LineString\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @function\n * @param {Position[][]} coordinates an array of LinearRings\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {Id} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString, GeoJsonProperties>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<LineString, P> {\n  return featureCollection(\n    coordinates.map((coords) => {\n      return lineString(coords, properties);\n    }),\n    options\n  );\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @function\n * @param {Array<Feature<GeometryObject, GeoJsonProperties>>} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection<GeometryObject, GeoJsonProperties>} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection<\n  G extends GeometryObject = Geometry,\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  features: Array<Feature<G, P>>,\n  options: { bbox?: BBox; id?: Id } = {}\n): FeatureCollection<G, P> {\n  const fc: any = { type: \"FeatureCollection\" };\n  if (options.id) {\n    fc.id = options.id;\n  }\n  if (options.bbox) {\n    fc.bbox = options.bbox;\n  }\n  fc.features = features;\n  return fc;\n}\n\n/**\n * Creates a {@link Feature}<{@link MultiLineString}> based on a\n * coordinate array. Properties can be added optionally.\n *\n * @function\n * @param {Position[][]} coordinates an array of LineStrings\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString, GeoJsonProperties>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString<\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  coordinates: Position[][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiLineString, P> {\n  const geom: MultiLineString = {\n    type: \"MultiLineString\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Feature}<{@link MultiPoint}> based on a\n * coordinate array. Properties can be added optionally.\n *\n * @function\n * @param {Position[]} coordinates an array of Positions\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint, GeoJsonProperties>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiPoint, P> {\n  const geom: MultiPoint = {\n    type: \"MultiPoint\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a {@link Feature}<{@link MultiPolygon}> based on a\n * coordinate array. Properties can be added optionally.\n *\n * @function\n * @param {Position[][][]} coordinates an array of Polygons\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon, GeoJsonProperties>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon<P extends GeoJsonProperties = GeoJsonProperties>(\n  coordinates: Position[][][],\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<MultiPolygon, P> {\n  const geom: MultiPolygon = {\n    type: \"MultiPolygon\",\n    coordinates,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Creates a Feature<GeometryCollection> based on a\n * coordinate array. Properties can be added optionally.\n *\n * @function\n * @param {Array<Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon>} geometries an array of GeoJSON Geometries\n * @param {GeoJsonProperties} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {BBox} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {Id} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection, GeoJsonProperties>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection<\n  P extends GeoJsonProperties = GeoJsonProperties,\n>(\n  geometries: Array<\n    Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon\n  >,\n  properties?: P,\n  options: { bbox?: BBox; id?: Id } = {}\n): Feature<GeometryCollection, P> {\n  const geom: GeometryCollection = {\n    type: \"GeometryCollection\",\n    geometries,\n  };\n  return feature(geom, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @function\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num: number, precision = 0): number {\n  if (precision && !(precision >= 0)) {\n    throw new Error(\"precision must be a positive number\");\n  }\n  const multiplier = Math.pow(10, precision || 0);\n  return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @function\n * @param {number} radians in radians across the sphere\n * @param {Units} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(\n  radians: number,\n  units: Units = \"kilometers\"\n): number {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @function\n * @param {number} distance in real units\n * @param {Units} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(\n  distance: number,\n  units: Units = \"kilometers\"\n): number {\n  const factor = factors[units];\n  if (!factor) {\n    throw new Error(units + \" units is invalid\");\n  }\n  return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @function\n * @param {number} distance in real units\n * @param {Units} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance: number, units?: Units): number {\n  return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @function\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing: number): number {\n  let angle = bearing % 360;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return angle;\n}\n\n/**\n * Converts any azimuth angle from the north line direction (positive clockwise)\n * and returns an angle between -180 and +180 degrees (positive clockwise), 0 being the north line\n *\n * @function\n * @param {number} angle between 0 and 360 degrees\n * @returns {number} bearing between -180 and +180 degrees\n */\nexport function azimuthToBearing(angle: number): number {\n  // Ignore full revolutions (multiples of 360)\n  angle = angle % 360;\n\n  if (angle > 180) {\n    return angle - 360;\n  } else if (angle < -180) {\n    return angle + 360;\n  }\n\n  return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @function\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians: number): number {\n  // % (2 * Math.PI) radians in case someone passes value > 2π\n  const normalisedRadians = radians % (2 * Math.PI);\n  return (normalisedRadians * 180) / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @function\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees: number): number {\n  // % 360 degrees in case someone passes value > 360\n  const normalisedDegrees = degrees % 360;\n  return (normalisedDegrees * Math.PI) / 180;\n}\n\n/**\n * Converts a length from one unit to another.\n *\n * @function\n * @param {number} length Length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] Input length unit\n * @param {Units} [finalUnit=\"kilometers\"] Returned length unit\n * @returns {number} The converted length\n */\nexport function convertLength(\n  length: number,\n  originalUnit: Units = \"kilometers\",\n  finalUnit: Units = \"kilometers\"\n): number {\n  if (!(length >= 0)) {\n    throw new Error(\"length must be a positive number\");\n  }\n  return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n\n/**\n * Converts an area from one unit to another.\n *\n * @function\n * @param {number} area Area to be converted\n * @param {AreaUnits} [originalUnit=\"meters\"] Input area unit\n * @param {AreaUnits} [finalUnit=\"kilometers\"] Returned area unit\n * @returns {number} The converted length\n */\nexport function convertArea(\n  area: number,\n  originalUnit: AreaUnits = \"meters\",\n  finalUnit: AreaUnits = \"kilometers\"\n): number {\n  if (!(area >= 0)) {\n    throw new Error(\"area must be a positive number\");\n  }\n\n  const startFactor = areaFactors[originalUnit];\n  if (!startFactor) {\n    throw new Error(\"invalid original units\");\n  }\n\n  const finalFactor = areaFactors[finalUnit];\n  if (!finalFactor) {\n    throw new Error(\"invalid final units\");\n  }\n\n  return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @function\n * @param {any} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num: any): boolean {\n  return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @function\n * @param {any} input variable to validate\n * @returns {boolean} true/false, including false for Arrays and Functions\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input: any): boolean {\n  return input !== null && typeof input === \"object\" && !Array.isArray(input);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {any} bbox BBox to validate\n * @returns {void}\n * @throws {Error} if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox: any): void {\n  if (!bbox) {\n    throw new Error(\"bbox is required\");\n  }\n  if (!Array.isArray(bbox)) {\n    throw new Error(\"bbox must be an Array\");\n  }\n  if (bbox.length !== 4 && bbox.length !== 6) {\n    throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n  }\n  bbox.forEach((num) => {\n    if (!isNumber(num)) {\n      throw new Error(\"bbox must only contain numbers\");\n    }\n  });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {any} id Id to validate\n * @returns {void}\n * @throws {Error} if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id: any): void {\n  if (!id) {\n    throw new Error(\"id is required\");\n  }\n  if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n    throw new Error(\"id must be a number or a string\");\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1038, "column": 0}, "map": {"version":3,"sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/%40turf/meta/index.js"],"sourcesContent":["import { feature, point, lineString, isObject } from \"@turf/helpers\";\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {number[]} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @function\n * @param {AllGeoJSON} geojson any GeoJSON object\n * @param {coordEachCallback} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n        ? geojson.geometry\n        : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {Reducer} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {number[]} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @returns {Reducer}\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @function\n * @param {AllGeoJSON} geojson any GeoJSON object\n * @param {coordReduceCallback} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {Reducer} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {Reducer} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {GeoJsonProperties} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @function\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {propEachCallback} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {Reducer} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {GeoJsonProperties} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @returns {Reducer}\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @function\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {propReduceCallback} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {Reducer} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {Reducer} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @function\n * @param {FeatureCollection|Feature|Feature<GeometryCollection>} geojson any GeoJSON object\n * @param {featureEachCallback} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {Reducer} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @returns {Reducer}\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @function\n * @param {FeatureCollection|Feature|Feature<GeometryCollection>} geojson any GeoJSON object\n * @param {featureReduceCallback} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {Reducer} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {Reducer} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @function\n * @param {AllGeoJSON} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {GeometryObject} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {GeoJsonProperties} featureProperties The current Feature Properties being processed.\n * @param {BBox} featureBBox The current Feature BBox being processed.\n * @param {Id} featureId The current Feature Id being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @function\n * @param {FeatureCollection|Feature|Geometry|GeometryObject|Feature<GeometryCollection>} geojson any GeoJSON object\n * @param {geomEachCallback} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n        ? geojson.geometry\n        : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n        ? geojson.properties\n        : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n        ? geojson.bbox\n        : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n        ? geojson.id\n        : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {Reducer} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {GeometryObject} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {GeoJsonProperties} featureProperties The current Feature Properties being processed.\n * @param {BBox} featureBBox The current Feature BBox being processed.\n * @param {Id} featureId The current Feature Id being processed.\n * @returns {Reducer}\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @function\n * @param {FeatureCollection|Feature|GeometryObject|GeometryCollection|Feature<GeometryCollection>} geojson any GeoJSON object\n * @param {geomReduceCallback} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {Reducer} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {Reducer} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @function\n * @param {FeatureCollection|Feature|GeometryObject|GeometryCollection|Feature<GeometryCollection>} geojson any GeoJSON object\n * @param {flattenEachCallback} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {Reducer} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @returns {Reducer}\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @function\n * @param {FeatureCollection|Feature|GeometryObject|GeometryCollection|Feature<GeometryCollection>} geojson any GeoJSON object\n * @param {flattenReduceCallback} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {Reducer} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {Reducer} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {AllGeoJSON} geojson any GeoJSON\n * @param {segmentEachCallback} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {Reducer} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {Reducer}\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {segmentReduceCallback} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {Reducer} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {Reducer}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n * @returns {void}\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @function\n * @param {FeatureCollection<Lines>|Feature<Lines>|Lines|Feature<GeometryCollection>|GeometryCollection} geojson object\n * @param {lineEachCallback} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @returns {void}\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {Reducer} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n * @returns {Reducer}\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @function\n * @param {FeatureCollection<Lines>|Feature<Lines>|Lines|Feature<GeometryCollection>|GeometryCollection} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {Reducer} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {Reducer} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport {\n  coordReduce,\n  coordEach,\n  propEach,\n  propReduce,\n  featureReduce,\n  featureEach,\n  coordAll,\n  geomReduce,\n  geomEach,\n  flattenReduce,\n  flattenEach,\n  segmentReduce,\n  segmentEach,\n  lineReduce,\n  lineEach,\n  findSegment,\n  findPoint,\n};\n"],"names":["feature"],"mappings":"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"}},
    {"offset": {"line": 1485, "column": 0}, "map": {"version":3,"sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/%40turf/clone/index.ts"],"sourcesContent":["import { Feature, GeoJsonProperties } from \"geojson\";\nimport { AllGeoJSON } from \"@turf/helpers\";\n\n/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @function\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone<T extends AllGeoJSON>(geojson: T): T {\n  if (!geojson) {\n    throw new Error(\"geojson is required\");\n  }\n\n  switch (geojson.type) {\n    case \"Feature\":\n      return cloneFeature(geojson);\n    case \"FeatureCollection\":\n      return cloneFeatureCollection(geojson);\n    case \"Point\":\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiPoint\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n    case \"GeometryCollection\":\n      return cloneGeometry(geojson);\n    default:\n      throw new Error(\"unknown GeoJSON type\");\n  }\n}\n\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson: any) {\n  const cloned: any = { type: \"Feature\" };\n  // Preserve Foreign Members\n  Object.keys(geojson).forEach((key) => {\n    switch (key) {\n      case \"type\":\n      case \"properties\":\n      case \"geometry\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  // Add properties & geometry last\n  cloned.properties = cloneProperties(geojson.properties);\n  if (geojson.geometry == null) {\n    cloned.geometry = null;\n  } else {\n    cloned.geometry = cloneGeometry(geojson.geometry);\n  }\n  return cloned;\n}\n\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties: GeoJsonProperties) {\n  const cloned: { [key: string]: any } = {};\n  if (!properties) {\n    return cloned;\n  }\n  Object.keys(properties).forEach((key) => {\n    const value = properties[key];\n    if (typeof value === \"object\") {\n      if (value === null) {\n        // handle null\n        cloned[key] = null;\n      } else if (Array.isArray(value)) {\n        // handle Array\n        cloned[key] = value.map((item) => {\n          return item;\n        });\n      } else {\n        // handle generic Object\n        cloned[key] = cloneProperties(value);\n      }\n    } else {\n      cloned[key] = value;\n    }\n  });\n  return cloned;\n}\n\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson: any) {\n  const cloned: any = { type: \"FeatureCollection\" };\n\n  // Preserve Foreign Members\n  Object.keys(geojson).forEach((key) => {\n    switch (key) {\n      case \"type\":\n      case \"features\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  // Add features\n  cloned.features = geojson.features.map((feature: Feature<any>) => {\n    return cloneFeature(feature);\n  });\n  return cloned;\n}\n\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry: any) {\n  const geom: any = { type: geometry.type };\n  if (geometry.bbox) {\n    geom.bbox = geometry.bbox;\n  }\n\n  if (geometry.type === \"GeometryCollection\") {\n    geom.geometries = geometry.geometries.map((g: any) => {\n      return cloneGeometry(g);\n    });\n    return geom;\n  }\n  geom.coordinates = deepSlice(geometry.coordinates);\n  return geom;\n}\n\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice<C = any[]>(coords: C): C {\n  const cloned: any = coords;\n  if (typeof cloned[0] !== \"object\") {\n    return cloned.slice();\n  }\n  return cloned.map((coord: any) => {\n    return deepSlice(coord);\n  });\n}\n\nexport { clone, cloneProperties };\nexport default clone;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1610, "column": 0}, "map": {"version":3,"sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/%40turf/projection/index.ts"],"sourcesContent":["import { Position } from \"geojson\";\nimport { coordEach } from \"@turf/meta\";\nimport { AllGeoJSON, isNumber } from \"@turf/helpers\";\nimport { clone } from \"@turf/clone\";\n\n/**\n * Converts a WGS84 GeoJSON object into Mercator (EPSG:900913) projection\n *\n * @function\n * @param {GeoJSON|Position} geojson WGS84 GeoJSON object\n * @param {Object} [options] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} Projected GeoJSON\n * @example\n * var pt = turf.point([-71,41]);\n * var converted = turf.toMercator(pt);\n *\n * //addToMap\n * var addToMap = [pt, converted];\n */\nfunction toMercator<G = AllGeoJSON | Position>(\n  geojson: G,\n  options: { mutate?: boolean } = {}\n): G {\n  return convert(geojson, \"mercator\", options);\n}\n\n/**\n * Converts a Mercator (EPSG:900913) GeoJSON object into WGS84 projection\n *\n * @function\n * @param {GeoJSON|Position} geojson Mercator GeoJSON object\n * @param {Object} [options] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} Projected GeoJSON\n * @example\n * var pt = turf.point([-7903683.846322424, 5012341.663847514]);\n * var converted = turf.toWgs84(pt);\n *\n * //addToMap\n * var addToMap = [pt, converted];\n */\nfunction toWgs84<G = AllGeoJSON | Position>(\n  geojson: G,\n  options: { mutate?: boolean } = {}\n): G {\n  return convert(geojson, \"wgs84\", options);\n}\n\n/**\n * Converts a GeoJSON coordinates to the defined `projection`\n *\n * @private\n * @param {GeoJSON} geojson GeoJSON Feature or Geometry\n * @param {string} projection defines the projection system to convert the coordinates to\n * @param {Object} [options] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} Converted GeoJSON\n */\nfunction convert(\n  geojson: any,\n  projection: string,\n  options: { mutate?: boolean } = {}\n): any {\n  // Optional parameters\n  options = options || {};\n  var mutate = options.mutate;\n\n  // Validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  // Handle Position\n  if (Array.isArray(geojson) && isNumber(geojson[0]))\n    geojson =\n      projection === \"mercator\"\n        ? convertToMercator(geojson)\n        : convertToWgs84(geojson);\n  // Handle GeoJSON\n  else {\n    // Handle possible data mutation\n    if (mutate !== true) geojson = clone(geojson);\n\n    coordEach(geojson, function (coord) {\n      var newCoord =\n        projection === \"mercator\"\n          ? convertToMercator(coord)\n          : convertToWgs84(coord);\n      coord[0] = newCoord[0];\n      coord[1] = newCoord[1];\n    });\n  }\n  return geojson;\n}\n\n/**\n * Convert lon/lat values to 900913 x/y.\n * (from https://github.com/mapbox/sphericalmercator)\n *\n * @private\n * @param {Array<number>} lonLat WGS84 point\n * @returns {Array<number>} Mercator [x, y] point\n */\nfunction convertToMercator(lonLat: number[]) {\n  var D2R = Math.PI / 180,\n    // 900913 properties\n    A = 6378137.0,\n    MAXEXTENT = 20037508.342789244;\n\n  // compensate longitudes passing the 180th meridian\n  // from https://github.com/proj4js/proj4js/blob/master/lib/common/adjust_lon.js\n  var adjusted =\n    Math.abs(lonLat[0]) <= 180 ? lonLat[0] : lonLat[0] - sign(lonLat[0]) * 360;\n  var xy = [\n    A * adjusted * D2R,\n    A * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * lonLat[1] * D2R)),\n  ];\n\n  // if xy value is beyond maxextent (e.g. poles), return maxextent\n  if (xy[0] > MAXEXTENT) xy[0] = MAXEXTENT;\n  if (xy[0] < -MAXEXTENT) xy[0] = -MAXEXTENT;\n  if (xy[1] > MAXEXTENT) xy[1] = MAXEXTENT;\n  if (xy[1] < -MAXEXTENT) xy[1] = -MAXEXTENT;\n\n  return xy;\n}\n\n/**\n * Convert 900913 x/y values to lon/lat.\n * (from https://github.com/mapbox/sphericalmercator)\n *\n * @private\n * @param {Array<number>} xy Mercator [x, y] point\n * @returns {Array<number>} WGS84 [lon, lat] point\n */\nfunction convertToWgs84(xy: number[]) {\n  // 900913 properties.\n  var R2D = 180 / Math.PI;\n  var A = 6378137.0;\n\n  return [\n    (xy[0] * R2D) / A,\n    (Math.PI * 0.5 - 2.0 * Math.atan(Math.exp(-xy[1] / A))) * R2D,\n  ];\n}\n\n/**\n * Returns the sign of the input, or zero\n *\n * @private\n * @param {number} x input\n * @returns {number} -1|0|1 output\n */\nfunction sign(x: number) {\n  return x < 0 ? -1 : x > 0 ? 1 : 0;\n}\n\nexport { toMercator, toWgs84 };\n"],"names":[],"mappings":";;;;;;;AACA,SAAS,iBAAiB;AAC1B,SAAqB,gBAAgB;AACrC,SAAS,aAAa;;;;AAiBtB,SAAS,WACP,OAAA,EACA,UAAgC,CAAC,CAAA,EAC9B;IACH,OAAO,QAAQ,SAAS,YAAY,OAAO;AAC7C;AAiBA,SAAS,QACP,OAAA,EACA,UAAgC,CAAC,CAAA,EAC9B;IACH,OAAO,QAAQ,SAAS,SAAS,OAAO;AAC1C;AAYA,SAAS,QACP,OAAA,EACA,UAAA,EACA,UAAgC,CAAC,CAAA,EAC5B;IAEL,UAAU,WAAW,CAAC;IACtB,IAAI,SAAS,QAAQ,MAAA;IAGrB,IAAI,CAAC,QAAS,CAAA,MAAM,IAAI,MAAM,qBAAqB;IAGnD,IAAI,MAAM,OAAA,CAAQ,OAAO,SAAK,qKAAA,EAAS,OAAA,CAAQ,CAAC,CAAC,GAC/C,UACE,eAAe,aACX,kBAAkB,OAAO,IACzB,eAAe,OAAO;SAEzB;QAEH,IAAI,WAAW,KAAM,CAAA,cAAU,gKAAA,EAAM,OAAO;QAE5C,IAAA,mKAAA,EAAU,SAAS,SAAU,KAAA,EAAO;YAClC,IAAI,WACF,eAAe,aACX,kBAAkB,KAAK,IACvB,eAAe,KAAK;YAC1B,KAAA,CAAM,CAAC,CAAA,GAAI,QAAA,CAAS,CAAC,CAAA;YACrB,KAAA,CAAM,CAAC,CAAA,GAAI,QAAA,CAAS,CAAC,CAAA;QACvB,CAAC;IACH;IACA,OAAO;AACT;AAUA,SAAS,kBAAkB,MAAA,EAAkB;IAC3C,IAAI,MAAM,KAAK,EAAA,GAAK,KAElB,IAAI,SACJ,YAAY;IAId,IAAI,WACF,KAAK,GAAA,CAAI,MAAA,CAAO,CAAC,CAAC,KAAK,MAAM,MAAA,CAAO,CAAC,CAAA,GAAI,MAAA,CAAO,CAAC,CAAA,GAAI,KAAK,MAAA,CAAO,CAAC,CAAC,IAAI;IACzE,IAAI,KAAK;QACP,IAAI,WAAW;QACf,IAAI,KAAK,GAAA,CAAI,KAAK,GAAA,CAAI,KAAK,EAAA,GAAK,OAAO,MAAM,MAAA,CAAO,CAAC,CAAA,GAAI,GAAG,CAAC;KAC/D;IAGA,IAAI,EAAA,CAAG,CAAC,CAAA,GAAI,UAAW,CAAA,EAAA,CAAG,CAAC,CAAA,GAAI;IAC/B,IAAI,EAAA,CAAG,CAAC,CAAA,GAAI,CAAC,UAAW,CAAA,EAAA,CAAG,CAAC,CAAA,GAAI,CAAC;IACjC,IAAI,EAAA,CAAG,CAAC,CAAA,GAAI,UAAW,CAAA,EAAA,CAAG,CAAC,CAAA,GAAI;IAC/B,IAAI,EAAA,CAAG,CAAC,CAAA,GAAI,CAAC,UAAW,CAAA,EAAA,CAAG,CAAC,CAAA,GAAI,CAAC;IAEjC,OAAO;AACT;AAUA,SAAS,eAAe,EAAA,EAAc;IAEpC,IAAI,MAAM,MAAM,KAAK,EAAA;IACrB,IAAI,IAAI;IAER,OAAO;QACJ,EAAA,CAAG,CAAC,CAAA,GAAI,MAAO;QAAA,CACf,KAAK,EAAA,GAAK,MAAM,IAAM,KAAK,IAAA,CAAK,KAAK,GAAA,CAAI,CAAC,EAAA,CAAG,CAAC,CAAA,GAAI,CAAC,CAAC,CAAA,IAAK;KAC5D;AACF;AASA,SAAS,KAAK,CAAA,EAAW;IACvB,OAAO,IAAI,IAAI,CAAA,IAAK,IAAI,IAAI,IAAI;AAClC"}},
    {"offset": {"line": 1674, "column": 0}, "map": {"version":3,"sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/fast-deep-equal/index.js"],"sourcesContent":["'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n"],"names":[],"mappings":"AAEA,sDAAsD;AAItD,OAAO,OAAO,GAAG,SAAS,MAAM,CAAC,EAAE,CAAC;IAClC,IAAI,MAAM,GAAG,OAAO;IAEpB,IAAI,KAAK,KAAK,OAAO,KAAK,YAAY,OAAO,KAAK,UAAU;QAC1D,IAAI,EAAE,WAAW,KAAK,EAAE,WAAW,EAAE,OAAO;QAE5C,IAAI,QAAQ,GAAG;QACf,IAAI,MAAM,OAAO,CAAC,IAAI;YACpB,SAAS,EAAE,MAAM;YACjB,IAAI,UAAU,EAAE,MAAM,EAAE,OAAO;YAC/B,IAAK,IAAI,QAAQ,QAAQ,GACvB,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,GAAG,OAAO;YACjC,OAAO;QACT;QAIA,IAAI,EAAE,WAAW,KAAK,QAAQ,OAAO,EAAE,MAAM,KAAK,EAAE,MAAM,IAAI,EAAE,KAAK,KAAK,EAAE,KAAK;QACjF,IAAI,EAAE,OAAO,KAAK,OAAO,SAAS,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO,OAAO,EAAE,OAAO;QAC5E,IAAI,EAAE,QAAQ,KAAK,OAAO,SAAS,CAAC,QAAQ,EAAE,OAAO,EAAE,QAAQ,OAAO,EAAE,QAAQ;QAEhF,OAAO,OAAO,IAAI,CAAC;QACnB,SAAS,KAAK,MAAM;QACpB,IAAI,WAAW,OAAO,IAAI,CAAC,GAAG,MAAM,EAAE,OAAO;QAE7C,IAAK,IAAI,QAAQ,QAAQ,GACvB,IAAI,CAAC,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,EAAE,GAAG,OAAO;QAEhE,IAAK,IAAI,QAAQ,QAAQ,GAAI;YAC3B,IAAI,MAAM,IAAI,CAAC,EAAE;YAEjB,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,GAAG,OAAO;QACrC;QAEA,OAAO;IACT;IAEA,oCAAoC;IACpC,OAAO,MAAI,KAAK,MAAI;AACtB","ignoreList":[0]}},
    {"offset": {"line": 1705, "column": 0}, "map": {"version":3,"sources":["file:///Users/sarahasif/Documents/Software%20Codes/my-tracking%20app/node_modules/%40mapbox/geojson-normalize/index.js"],"sourcesContent":["module.exports = normalize;\n\nvar types = {\n    Point: 'geometry',\n    MultiPoint: 'geometry',\n    LineString: 'geometry',\n    MultiLineString: 'geometry',\n    Polygon: 'geometry',\n    MultiPolygon: 'geometry',\n    GeometryCollection: 'geometry',\n    Feature: 'feature',\n    FeatureCollection: 'featurecollection'\n};\n\n/**\n * Normalize a GeoJSON feature into a FeatureCollection.\n *\n * @param {object} gj geojson data\n * @returns {object} normalized geojson data\n */\nfunction normalize(gj) {\n    if (!gj || !gj.type) return null;\n    var type = types[gj.type];\n    if (!type) return null;\n\n    if (type === 'geometry') {\n        return {\n            type: 'FeatureCollection',\n            features: [{\n                type: 'Feature',\n                properties: {},\n                geometry: gj\n            }]\n        };\n    } else if (type === 'feature') {\n        return {\n            type: 'FeatureCollection',\n            features: [gj]\n        };\n    } else if (type === 'featurecollection') {\n        return gj;\n    }\n}\n"],"names":[],"mappings":"AAAA,OAAO,OAAO,GAAG;AAEjB,IAAI,QAAQ;IACR,OAAO;IACP,YAAY;IACZ,YAAY;IACZ,iBAAiB;IACjB,SAAS;IACT,cAAc;IACd,oBAAoB;IACpB,SAAS;IACT,mBAAmB;AACvB;AAEA;;;;;CAKC,GACD,SAAS,UAAU,EAAE;IACjB,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,EAAE,OAAO;IAC5B,IAAI,OAAO,KAAK,CAAC,GAAG,IAAI,CAAC;IACzB,IAAI,CAAC,MAAM,OAAO;IAElB,IAAI,SAAS,YAAY;QACrB,OAAO;YACH,MAAM;YACN,UAAU;gBAAC;oBACP,MAAM;oBACN,YAAY,CAAC;oBACb,UAAU;gBACd;aAAE;QACN;IACJ,OAAO,IAAI,SAAS,WAAW;QAC3B,OAAO;YACH,MAAM;YACN,UAAU;gBAAC;aAAG;QAClB;IACJ,OAAO,IAAI,SAAS,qBAAqB;QACrC,OAAO;IACX;AACJ","ignoreList":[0]}}]
}